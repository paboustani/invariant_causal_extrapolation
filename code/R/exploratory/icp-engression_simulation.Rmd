---
title: "engression_worksheet"
author: "Philip Boustani"
date: "2024-03-24"
output: html_document
---

# Setup Rmarkdown

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# install and loed packages

```{r}
# List of required packages
packages <- c(
  "engression",
  "CondIndTests", 
  "lawstat", # For levene.test
  "stats", # For ks.test, wilcox.test
  "mgcv" # for fitting GAMs
)

# First, installing packages which are not yet installed and then loading all of them
for (pkg in packages) {
  if(!require(pkg, character.only = TRUE)){
    install.packages(pkg, character.only = TRUE);
    library(pkg, character.only = TRUE)
  }
}
```

# load all required source files

```{r}
# List of required source files
files <- c(
  "nonlinearICPsimulation.R", 
  "external_modified/InvResDisTest.R", 
  "external_modified/gamResidualDistributions.R",
  "external_modified/getgam.R",
  "external_modified/ksResidualDistributions.R",
  "external_modified/leveneAndWilcoxResidualDistributions.R"
)

# Detect working directory and load all files 
directory <- getwd()
paths <- file.path(directory, files)
for (path in paths) {
  source(path)
}
```


```{r}
accepted_sets <- function(pvals, S_sets, alpha = 0.05) {
  # Initialize an empty list to store the sets
  selected_sets <- list()
  
  # Iterate through each element of pvals
  for (i in seq_along(pvals)) {
    # Check if the p-value is not smaller than 0.05
    if (pvals[i] >= alpha) {
      # Add the corresponding set/vector from S_sets to the list
      selected_sets[[length(selected_sets) + 1]] <- S_sets[[i]]
    }
  }
  
  # Return the list of selected sets
  return(selected_sets)
}

get_union <- function(selected_sets) {
  # Initialize an empty set to store the union
  union_set <- NULL
  
  # Iterate through each set in selected_sets and update the union
  for (set in selected_sets) {
    union_set <- union(union_set, set)
  }
  
  # Return the union set
  return(union_set)
}

get_intersection <- function(selected_sets) {
  # Check if the selected_sets list is not empty
  if (length(selected_sets) == 0) {
    return(NULL)  # If the list is empty, return NULL
  }
  
  # Initialize the intersection set with the first set in selected_sets
  intersection_set <- selected_sets[[1]]
  
  # Iterate through each set in selected_sets and update the intersection
  for (i in 2:length(selected_sets)) {
    intersection_set <- intersect(intersection_set, selected_sets[[i]])
  }
  
  # Return the intersection set
  return(intersection_set)
}
```


# Invariant residual distribution test for nonlinear ICP

```{r}
n <- sample(c(100, 200, 500, 2000, 5000),1); n
Sim <- gen_sample(n = n, d = d, dag = dag, signs = dag_signs, verbose = FALSE)

target <- Sim$statistics[2]; target
parents <- get_parents(target,dag = dag); parents

S_sets <- obtain_S(target, d)

pvals <- rep(NA, length(S_sets))

for (k in 1:length(S_sets)) {
  S_k <- S_sets[[k]]
  
  pvals[k] <- InvResDisTest(
    Y = Sim$sample[,target], E = as.factor(Sim$sample[,"E"]), X = Sim$sample[,S_k], 
    alpha = 0.05,
    verbose = FALSE, fitmodel = "GAM",
    test = leveneAndWilcoxResidualDistributions, colNameNoSmooth = NULL,
    mtry = sqrt(NCOL(X)), ntree = 100, nodesize = 5, maxnodes = NULL,
    returnModel = FALSE
  )$pvalue
}

selected_sets <- accepted_sets(pvals, S_sets)
union_set <- get_union(selected_sets); union_set
intersection_set <- get_intersection(selected_sets); intersection_set
```



```{r}
# plot(x = S1$sample[,c(1)], y = S1$sample[,2], type = 'n')
# 
# # Plot the original data points
# points(S1$sample[,c(1)], S1$sample[,2], 
#        col = rgb(S1$sample[, "E"]==1, S1$sample[, "E"]==2, S1$sample[, "E"]==3, alpha = 0.4), pch = 16)
```
